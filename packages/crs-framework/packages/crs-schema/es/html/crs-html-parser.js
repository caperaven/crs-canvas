class e{constructor(e){this.parser=e,this.isManager=!0}dispose(){this.reset(),delete this.parser}reset(){}assert(e,t,s){const r=1==e();return r&&t.push(s),!r}validate(e,t){if(null!=e.elements)for(let s of e.elements)this.parser.validateItem(s,t)}reset(){}}class t extends e{get key(){return"templates"}reset(){for(let e of this._parts||[])null!=this[e]&&(this[e].clear(),this[e]=null)}initialize(){this._parts=[],this._load("templates")}_load(e){null==this[e]&&(this[e]=new Map,this._parts.push(e));const t=this.parser.schema[e];for(let s of t)null==s.import?this[e].set(s.id,s):this._load(s.import)}getTemplate(e,t){if(0==this[e].has(t))throw new Error(`There is no template in the schema for with id "${t}"`);return this[e].get(t)}validate(e,t){this.assert(()=>0==Array.isArray(e),t,"templates definition must be a array")&&(this.initialize(e),this.templates.forEach(e=>{this.assert(()=>null==e.id,t,"template must have a valid id property"),this.assert(()=>null==e.elements,t,"template must have a elements property"),this.assert(()=>1!=Array.isArray(e.elements),t,"template elements property should be an array"),this.assert(()=>0==(e.elements||[]).length,t,"template elements must contain content")&&super.validate(e,t)}))}}class s extends e{get key(){return"variables"}get valueProcessor(){return!0}reset(){delete this.variables}initialize(e){this.variables=e}process(e){return this.getValue(e)}getValue(e){if("string"!=typeof e||"@"!=e.trim()[0])return e;e=e.slice(1);let t=new Function("variables",`return variables.${e}`);const s=t(this.variables);return t=null,s}}class r{constructor(e){this.parser=e}dispose(){delete this.parser}shouldParse(e){return!0}process(e){return null!=this.styles&&(e.styles=[]),{children:this.parser.parseChildren(e),attributes:this.parser.parseAttributes(e),styles:this.parser.parseStyles(e),content:this.parser.parseContent(e)}}setValues(e,t){const s=Object.keys(t);for(let r of s){const s=null!=t[r]?t[r]:"";e=e.split(r).join(s)}return e}validate(e,t){if(null!=e.elements)for(let s of e.elements)this.parser.validateItem(s,t)}assert(e,t,s){const r=1==e();return r&&t.push(s),!r}}class i extends r{get key(){return"body"}get template(){return"__content__"}process(e){const t=super.process(e);return this.setValues(this.template,{__content__:t.children})}validate(e,t){this.assert(()=>Array.isArray(e),t,"Body element must be a object not an array"),this.assert(()=>null==e.elements,t,"elements property required on body"),this.assert(()=>0==Array.isArray(e.elements),t,"element property on body must be an array"),super.validate(e,t)}}class a extends r{get key(){return"raw"}get template(){return"<__element__ __attributes__ __styles__>__content__</__element__>"}process(e,t){const s=super.process(e);return this.setValues(this.template,{__element__:t,__attributes__:s.attributes,__styles__:s.styles,__content__:s.children||s.content||""})}validate(e,t){super.validate(e,t)}}class n extends r{get key(){return"template"}get template(){return"<div __attributes__ __classes__ >\n                    __content__\n                </div>"}process(e,t){const s=this.parser.managers.get("templates");if(null==s)throw new Error("templates manager should be registered");let r=Object.getOwnPropertyNames(e).find(e=>-1!==e.toLowerCase().indexOf("template"));const i=e[r];"template"==r&&(r="templates");const a=s.getTemplate(r,i);e.elements=a.elements;const n=super.process(e);return this.setValues(this.template,{__attributes__:n.attributes,__classes__:n.styles,__content__:n.children})}processTemplate(e){return super.process(e).children}validate(e,t){this.assert(()=>null==e.template,t,"template element must have a valid template property")}}const l='<svg xmlns:xlink="http://www.w3.org/1999/xlink"><use xlink:href="#__icon__"/></svg>';class o extends r{get key(){return"button"}get template(){return"<button __attributes__ __styles__>__content__</button>"}process(e,t){const s=super.process(e),r=this.parser.parseStringValue(e.caption),i=null==e.icon?"":l.split("__icon__").join(e.icon),a=null==e.icon?`<span>${r}</span>`:`${i}<span>${r}</span>`;return this.setValues(this.template,{__attributes__:s.attributes,__styles__:s.styles,__content__:a})}validate(e,t){this.assert(()=>null==e.caption,t,"button must have a caption")}}class h extends class extends class{constructor(e){this.attributes=e,this.providers=new Map,this.managers=new Map,this.valueProcessors=[]}dispose(){this.providers.clear(),delete this.providers,this.managers.clear(),delete this.managers,this.valueProcessors.length=0,this.options=0}register(e){const t=new e(this);1==t.isManager?(this.managers.set(t.key,t),1==t.valueProcessor&&this.valueProcessors.push(t)):this.providers.set(t.key,t)}async load(e){for(let t of e||[])this.register((await import(t)).default)}init(){this.managers.forEach(e=>{e.reset&&e.reset()});const e=Object.keys(this.schema);for(let t of e)t!=this.options.root&&this.managers.has(t)&&this.managers.get(t).initialize(this.schema[t])}processStyleImports(e){if(this.styleImports.length>0){const t=[];this.styleImports.forEach(e=>t.push(`@import "${e}";`)),e=`<style>${t.join("\n")};</style>${e}`}return e}validate(){}}{constructor(e){super(e),this.styleImports=[],this.options={elementKey:"element",childrenKey:"elements",attributesKey:"attributes",stylesKey:"styles",root:"body",contentKey:"content"}}dispose(){super.dispose(),this.styleImports.length=0,this.options=null}async initialize(){this.register(t),this.register(s),this.register(i),this.register(a),this.register(n),this.register(o)}parseItem(e,t){if(null!=e)if(t=t||e[this.options.elementKey],this.providers.has(t)){const s=this.providers.get(t);if(!1!==s.shouldParse(e))return s.process(e)}else{const s=this.providers.get("raw");if(!1!==s.shouldParse(e))return s.process(e,t)}}parseAttributes(e){const t=e[this.options.attributesKey];if(null==t)return null;const s=[];return Object.entries(t).forEach(e=>{const t=e[0];let r=e[1];r=this.parseStringValue(r,t),s.push(`${t}="${r}"`)}),s.join(" ")}parseStyles(e){let t=e[this.options.stylesKey];return null==t?null:(Array.isArray(t)&&(t=t.join(" ")),`class="${t}"`)}parseChildren(e){const t=e[this.options.childrenKey];if(null==t)return null;const s=[];for(let e of t)s.push(this.parseItem(e));return s.join("")}parseContent(e){let t=e[this.options.contentKey];return null==t?null:(t=this.parseStringValue(t),t)}parseStringValue(e,t){for(let s of this.valueProcessors)e=s.process(e,t);return e}}{addStyleImports(e){Array.isArray(e)?e.forEach(e=>this.styleImports.push(e)):this.styleImports.push(e)}parse(e){if(this.schema=e,this.init(),0==this.providers.has(this.options.root))throw new Error(`schema requires a "${this.options.root}" option`);const t=e[this.options.root];if(null==t)throw new Error(`schema should have a property "${this.options.root}"`);let s=this.providers.get(this.options.root).process(t);return s=this.processStyleImports(s),this.managers.forEach(e=>e.reset()),delete this.schema,s}validate(e,t){const s=this.providers.get(this.options.root);null==s&&t.push("a root provider was not registered");const r=Object.keys(e);for(let s of r)if(s!=this.options.root&&this.managers.has(s)){const r=this.managers.get(s);null!=r.validate&&r.validate(e[s],t)}const i=e[this.options.root];s&&s.validate(i,t)}validateItem(e,t){const s=e.element;let r=this.providers.get(s);null==r&&(r=this.providers.get("raw")),r.validate&&r.validate(e,t)}}"undefined"!=typeof self&&(self.crs=self.crs||{},self.crs.HTMLParser=h);export{h as HTMLParser};
//# sourceMappingURL=crs-html-parser.js.map
